# -*- coding: utf-8 -*-
"""tsne-from-preset-params.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cZTfwwprTgURjXxNx5kuISoxSWB8SDvu

# Dataset Visualization Notebook (MFCC)

---

Author: **Malek Ibrahim**

This notebooks seeks to create a TSNE plot of the preset dataset in their timbral space (MFCC features). General steps are outlined below:

1. Load the preset dataset file
1. Categorize the presets
1. Prepare the DataFrame
1. Obtain the TSNE 2D embeddings from the higher-dimensional MFCC features
1. Plot the results!

## Imports

---

For this script, we will need Pytorch to load the dataset, scikit-learn for the TSNE plot functionality, and also plotly to visualize the results.
"""

import torch
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import matplotlib.pyplot as plt
import pandas as pd
import os
from sklearn.manifold import TSNE
import sys;sys.path.append(f'{os.sep}'.join(sys.path[0].split(os.sep)[0:-1]))
from src.utils import *

"""## Load the Preset Dataset

---

Load the preset from the saved `.pt` file and inspect its structure.
"""

dataset = torch.load('preset_dataset.pt')

dataset.keys()

dataset['preset_names']

# we need to convert the preset names to a categorical variable in order to group the points in the scatter plot
categorized_names = {name: categorize_name(name) for name in dataset['preset_names']}

categorized_names

"""## Create the Pandas DataFrame for Input to the TSNE Plot

---

We need to put our dataset into a form that is friendly for the TSNE plot. Specifically, we plan to put everything into an ordered table, a Pandas DataFrame.  
"""

# initialize a pandas dataframe
df = pd.DataFrame()

# add a column for the preset names
df['preset_name'] = dataset['preset_names']

# add a column for the categorized preset names
df['categorized_name'] = [categorized_names[name] for name in dataset['preset_names']]

# add a column for the MFCC features (should we normalize these?)
df['mfcc'] = [torch.mean(mfcc['C3'], axis=1) for mfcc in dataset['MFCCs']] # for now, use C3, we can try other notes and see if we get different results.

# visualize the first few rows of df
df.head(5)

# remove all rows in the df that are miscellaneous or other
df_filtered = df[df['categorized_name'] != 'Miscellaneous/Other']

# reset the index of the dataframe
df_filtered = df_filtered.reset_index(drop=True)

len(df_filtered)

# visualize the filtered dataframe
df_filtered.head(5)

# normalize the mfcc features to be 0 to 1 (per feature basis normalization)
df_filtered['mfcc'] = [normalize_zero_to_one(mfcc) for mfcc in df_filtered['mfcc']]

# normalize the mfcc features to 0 to 1 using the min and max of the entire dataset
max_value = torch.max(torch.stack(df_filtered['mfcc'].tolist()))
min_value = torch.min(torch.cat(df_filtered['mfcc'].tolist()))
df_filtered['mfcc'] = [normalize_zero_to_one(mfcc, min_value=min_value, max_value=max_value) for mfcc in df_filtered['mfcc']]

"""### Obtain the TSNE Transformed Data

---

Here we will initialize a TSNE object and apply a `fit_transform` to obtain a dimensionally reduced vector from the high dimensional input data.
"""

# we need to first convert the MFCC embeddings from torch format to numpy format for the TSNE algorithm
embeddings =  np.stack(df['mfcc'].apply(lambda x: x.cpu().numpy()))

# obtain the filtered embeddings
filtered_embeddings = np.stack(df_filtered['mfcc'].apply(lambda x: x.cpu().numpy()))

# Before we obtain the TSNE embeddings, let's first visualize the distribution of the MFCC embeddings
plt.hist(embeddings.flatten(), bins=1000)
plt.xlim([-50,50])
plt.title('Distribution of MFCC Embeddings Values')
plt.show()

# plot the distribution of filtered embeddings
plt.hist(filtered_embeddings.flatten(), bins=250)
plt.xlim([0,1])
plt.show()

# get the TSNE transform
transformed_data = generate_tsne(embeddings)

filtered_transformed_data = generate_tsne(filtered_embeddings, perplexity=20)

# inspect the transformed data
transformed_data.shape

# create an x and y column in the dataframe
df['x'] = [transformed_data[i][0] for i in range(len(transformed_data))]
df['y'] = [transformed_data[i][1] for i in range(len(transformed_data))]

# create a filtered x and filtered y column in the dataframe
df_filtered['x'] = [filtered_transformed_data[i][0] for i in range(len(filtered_transformed_data))]
df_filtered['y'] = [filtered_transformed_data[i][1] for i in range(len(filtered_transformed_data))]

"""## Create the TSNE Plot

---

Let's now use Plotly to visualize these embeddings!
"""

## Create the TSNE Plot with plotly
fig = px.scatter(df_filtered, x='x', y='y', color='categorized_name',hover_data=['preset_name', 'categorized_name'], width=800, height=800)

# add a legend
fig.update_layout(showlegend=True)

# add a title
fig.update_layout(title='TSNE Visualization of Preset MFCC Embeddings')

# add a hover label
fig.update_traces(hovertemplate='Preset Name: %{customdata[0]}<br>Categorized Name: %{customdata[1]}')

# obtain the data bounds
x_min = np.min(filtered_transformed_data[:, 0])*1.2
x_max = np.max(filtered_transformed_data[:, 0])*1.2
y_min = np.min(filtered_transformed_data[:, 1])*1.2
y_max = np.max(filtered_transformed_data[:, 1])*1.2

# add some extra info to the plot
fig.update_layout(
    width=800,
    height=800,
    xaxis_title='t-SNE Component 1',
    yaxis_title='t-SNE Component 2',
    legend_title='Preset Categories',
    xaxis=dict(range=[x_min, x_max]),
    yaxis=dict(range=[y_min, y_max]),
)   

# show the plot
fig.show()

